
public static String lettersInSentence(String sentence)
# Purpose: Returns a string of unique characters in the range [a...z] in alphabetical order; such that the appearence of a character implies it appears at least once in the input string sentence. Characters in the range [A...Z] can (i.e. should) be converted to lower-case. Disregard all other characters in the string. You may NOT use any data structures from the Java Collections Framework.
# Input: String sentence – the input sentence 
# Hint: We went over this exact method in class a week ago (told 'ya I'd include it as a HW problem). That Said, another hint is that you only need to worry about alphabet characters.


public static String[] lettersCountInSentence(String sentence)
# Purpose: Returns an array of Strings in which each is composed of a unique character in the range [a...z], followed by a colon character (i.e. ':'), followed by a number (x>0) indicating how many times it appears in the sentence. The array elements should be in alphabetical order WRT their alphabet character component. Characters in the range [A...Z] can (i.e. should) be converted to lower-case and counted with their respective lower-case char (i.e. count 'E' with all occurences of 'e'). Disregard all other characters in the string. You may NOT use any data structures from the Java Collections Framework.
# Input: String sentence – the input sentence
# Hint: As we also noted last week: you might want to get 'lettersInSentence' working first; as this code [should] build thereupon.
# Examples: 
  > Input: "Banana!" => Output: {"a:3","b:1","n:2"}
  > Input: "A maroon balloon, floating to the Moon... in a monsoon!" => 
    Output: {"a:5","b:1","e:1","f:1","g:1","h:1","i:2","l:3","m:3","n:7",o:11","r:1","s:1","t:3",}


public static float getCommuteTime(char wType, int hour, float bTime, float[] delayFacs)
# Purpose: Returns the total time of a commute given the base commute time, current type of weather, current time of day, and how weather and time affect the commute. The type of weather will be input as char 'wType' with values: {'c' (clear), 'f' (foggy), 'r' (rainy), 's' (snowy), 'e' (???)}. The current hour will input as int 'hour' of range [0,23] where 0=>midnight and 23=>11pm; and the hour will be considered 'rush hour' if between 6-10am inclusive and 4-7pm exclusive. The float 'bTime' is the base time it takes for the commute (i.e. if the weather is sunny, WLOG). The float array 'delayFacs' provides the delay factors given weather type and whether or not it's rush hour; i.e. is as follows (where 'h'->'is rush hour'): {(f∧!h), (f∧h), (r∧!h), (r∧h), (s∧!h), (s∧h), (e∧!h), (e∧h)}. If the weather is clear (i.e. wType=='c'), do not apply any delay factors (you COULD multiply the base times by 1, but what's the point?) Return the resulting commute time truncated to two decimal places (i.e. resulting total commute of 16.5425 should be reduced to 16.54). Lastly: 'helper methods' (i.e. custom-built methods outside this one to help solve it) are NOT permitted; IOW: all of the code to solve this problem must be within this method! Our reason: we want you to think about the control-flow constructs on this one; we'll get plenty of time to work with functional programming otherwise.
# Input: As aforementioned
# Hints: 
  > The third-to-last sentence of the problem definition is your first hint. 
  > This method is mostly 'work' vis-a-vis putting together (i.e. computing) the commute time based on the input values. 
  > The last sentence of the problem is another hint: you could shrink the bulk of the work down to nested control flow constructs (i.e. several nested within a primary one).


### Instructions:
The 'Caesar Cipher' [(Wikipedia Link)](https://en.wikipedia.org/wiki/Caesar_cipher) was used by Gaius Julius Caesar himself for his private correspondence. We'll implement the simplest version in this assignment (and maybe step things up to more intermediate cryptographic methods in future assignments). The simplest version involves an **encoding step** of 'shifting' (analogously, 'rotating') the alphabet by some number of characters **x** in one of two directions **d** {left xor right}, then a **decoding step** of shifting the characters of the encrypted message **x** characters in the opposite direction. The offset **x** and direction **d** thus become the 'keys' used to encrypt and decrypt the message. Correspondingly, implement the following two methods...

### caesarCipherEncrypt
```Java
public static String caesarCipherEncrypt(String input, int offKey, char rotDir)
```
* **Purpose:** Given a message to be encrypted, an offset key, and rotation direction - encrypt the message into its corresponding encrypted form.
* **Inputs:**
  * `String input` - the message to be encrypted
  * `int offKey` - the number of characters to offset when encrypting (range `[0,...,25]`)
  * `char rotDir` - the direction `[left⊕right]` by which to offset characters (range `[0,...,25]`)
* **Example 1:** `caesarCipherEncrypt("secret",3,'r')=> "pbzobq"
* **Example 2:** `caesarCipherEncrypt("secret",7,'r')=> "lxvkxm"
* **Example 3:** `caesarCipherEncrypt("secret",4,'l')=> "wigvix"

### caesarCipherDecrypt
```Java
public static String caesarCipherDecrypt(String input, int offKey, char rotDir)
```
* **Purpose:** Given an encrypted message, an offset key, and rotation direction - decrypt the message back into its original non-encrypted form.
* **Inputs:**
  * `String input` - the encrypted message to be decrypted
  * `int offKey` - the number of characters to offset when decrypting (range `[0,...,25]`)
  * `char rotDir` - the direction `[left⊕right]` by which **the message was originally encrypted**
* **Example 1:** `caesarCipherDecrypt("pbzobq",3,'r')=> "secret"
* **Example 2:** `caesarCipherDecrypt("lxvkxm",7,'r')=> "secret"
* **Example 3:** `caesarCipherDecrypt("wigvix",4,'l')=> "secret"
* **Hint:** There's some text bolded in the description of parm `rotDir` for a reason.



Additional Problems via CodingBat that you'll submit solutions to via Repl (else Classroom):

From 'String-2':
  > xyzMiddle
  > mixString 
  > repeatSeparator
  > wordEnds
  > zipZap
  > repeatSeparator